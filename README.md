# pythonDigitalms

## 1. Задание ETL:

[Формулировка](docs/Тестовое%20задание,%20ETL.docx)  

[Тестовые данные](docs/Тестовое%20задание,%20ETL.xlsx)  

Для корректной работы необходима настройка окружения, см. [Переменные среды](#переменные-среды). БД создается при 
отсутствии, данные загружаются при запуске приложения. Так же при запуске формируется файл для отправки. Возможно 
это не то, что ожидалось, но формирование файла по запросу в ТЗ не обговаривалось.

Формально для работы достаточно одного запроса, но в текущем решении плоская таблица при загрузке нормализуется.

Сделаны некоторые предположения:
 - наименование компании/мед учреждения ограничено 250 символами и может быть не уникальным;
 - компания/мед учреждение относится к региону и не может числиться в нескольких регионах одновременно;
 - ИНН организации состоит из 12 символов (может быть достаточно и 10, но надо уточнять), формально ИНН организации 
   уникален, но так как в исходных данных одна организация числится в нескольких регионах, то уникальность 
   установлена для пары `ИНН`, `Регион`, т.е. организация с одним ИНН в разных регионах - это две разные организации;
 - столбцы `Статус` и `Тип вывода из оборота`: требуется уточнить к какой сущности они принадлежат, но так как эта 
   информация не используются в итоговом выводе, столбцы просто выведены в отдельные классификаторы и привязаны 
   непосредственно в `overdue`;
 - `ГТИН` просится в отдельный справочник `Номенклатура`, но чтобы не усложнять сделал справочник `Позиции` с полями: 
   ГТИН, серия, дозы (если я правильно помню, то это аббревиатура `номер` у медикаментов). Уникальность на уровне 
   ГТИН и серия;
 - `Количество доз` - это вычисляемое поле и его в БД не вносил;
 - столбец `Просрочено дней`. Полагаю это вычисляемый столбец, и отчет генерировался на 09.06.22. Мне кажется этот 
   столбец не должен быть представлен в БД, а быть скорее параметром запроса. Например, сколько будет просроченных 
   позиций на <произвольная дата> по регионам. Но так как в ТЗ нет уточнений по этому поводу, столбец отнесен к 
   сущности Позиция. В общем пошел по самому простому пути.

### Дополнительно
Решение упаковано в docker контейнеры:
- контейнер postgres;
- контейнер приложения.

**Важно**: решение демонстрационное, поэтому база не выведена на отдельный volume.

### Переменные среды
Для запуска и тестирования проекта, требуется создать файл `.env` с переменными окружения.
Пример файла: [.env.example](.env.sample)

Параметры:
- `POSTGRES_HOST` - имя хоста;
- `POSTGRES_PORT` - порт;
- `POSTGRES_DB` - имя базы данных;
- `POSTGRES_USER` - пользователь;
- `POSTGRES_PASSWORD` - пароль;
- `TG_BOT_TOKEN` - токен бота.

### Проверка работы
Проверить телеграм бота можно по адресу: t.me/khaykin_bot (self-hosted).

### Инструкция для развертывания (docker)

#### 1. Клонируйте репозиторий:
```shell
git clone git@github.com:mkhaykin/pythonDigitalms.git
cd pythonDigitalms
```

### 2. Создайте файл .env с переменными окружения.
Пример файла: [.env.example](.env.sample). Подобнее в разделе см. [Переменные среды](#переменные-среды).

### 3. Запустите контейнеры.
```shell
docker compose up -d
```
Важно: при наличии на хосте нескольких контейнеров с postgres может потребоваться корректировка файла 
`docker-compose.yml`. Необходимо убрать раздел `ports`. 

## 2. Задание Python:
[Формулировка](docs/Тестовое%20задание,%20Python.docx)


### Задача 1 

Дан массив целых чисел nums и целое число target. Необходимо вернуть индексы двух чисел таких, 
чтобы их сумма равна target. Имеется ровно одно решение.
Один и тот же элемент нельзя использовать дважды.
Результат можно вернуть в любом порядке.

[Решение](/tasks/task1.py)  

Нотация Big O: 
- память: O(n)
- время: O(n)

### Задача 2 
Вы продукт-менеджер и в настоящее время возглавляете команду по разработке нового продукта.  К сожалению, последняя 
версия вашего продукта не прошла проверку качества. Поскольку каждая версия разрабатывается на основе предыдущей 
версии, все версии после сломанной версии тоже сломаны.
Предположим, у вас есть n версий [1, 2, ..., n] и вы хотите найти первую сломанную версию, из-за которой все 
последующие будут сломаны. Вам предоставляется bool API isBrokenVersion (версия), который возвращает, является ли 
версия сломанной. Реализуйте функцию для поиска первой сломанной версии. Вы должны свести к минимуму количество 
обращений к API. 

[Решение](/tasks/task2.py)

Нотация Big O:  
- память: O(1)  
- время: O(log(n)) 
